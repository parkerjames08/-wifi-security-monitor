"""
Alert System and Notifications
Handles threat notifications and user alerts
"""
import smtplib
import json
import logging
import os
from datetime import datetime, timedelta
from typing import List, Dict, Optional
import config

# Optional imports for email functionality
try:
    from email.mime.text import MimeText
    from email.mime.multipart import MimeMultipart
    EMAIL_AVAILABLE = True
except ImportError:
    EMAIL_AVAILABLE = False
    MimeText = None
    MimeMultipart = None

class AlertSystem:
    """Comprehensive alert and notification system"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.alert_history = []
        self.notification_methods = []
        self.setup_notification_methods()
    
    def setup_notification_methods(self):
        """Initialize available notification methods"""
        # Email notifications
        if config.ENABLE_EMAIL_ALERTS and config.EMAIL_USERNAME:
            self.notification_methods.append('email')
        
        # System notifications (for desktop environments)
        if self.check_desktop_notifications():
            self.notification_methods.append('desktop')
        
        # Log-based alerts (always available)
        self.notification_methods.append('log')
        
        self.logger.info(f"Notification methods: {', '.join(self.notification_methods)}")
    
    def check_desktop_notifications(self) -> bool:
        """Check if desktop notifications are available"""
        try:
            import gi
            gi.require_version('Notify', '0.7')
            from gi.repository import Notify
            return Notify.init("WiFi Security Monitor")
        except (ImportError, ValueError):
            return False
    
    def send_threat_alert(self, network_data: Dict, threat_analysis: Dict):
        """Send alert for detected threat"""
        alert = {
            'timestamp': datetime.now().isoformat(),
            'type': 'threat_detected',
            'severity': threat_analysis.get('severity_level', 'medium'),
            'network': network_data,
            'analysis': threat_analysis,
            'alert_id': len(self.alert_history)
        }
        
        # Store alert
        self.alert_history.append(alert)
        
        # Send notifications
        self.send_notifications(alert)
        
        # Log alert
        self.log_alert(alert)
    
    def send_notifications(self, alert: Dict):
        """Send alert through all configured notification methods"""
        for method in self.notification_methods:
            try:
                if method == 'email':
                    self.send_email_alert(alert)
                elif method == 'desktop':
                    self.send_desktop_notification(alert)
                elif method == 'log':
                    self.send_log_notification(alert)
            except Exception as e:
                self.logger.error(f"Failed to send {method} notification: {e}")
    
    def send_email_alert(self, alert: Dict):
        """Send email alert"""
        if not config.EMAIL_RECIPIENTS or not EMAIL_AVAILABLE:
            return
        
        network = alert['network']
        analysis = alert['analysis']
        
        # Create email content
        subject = f"🚨 WiFi Threat Alert - {alert['severity'].upper()}"
        
        body = f"""
WiFi Security Monitor Alert

THREAT DETECTED: {alert['severity'].upper()} Risk

Network Details:
• SSID: {network.get('ssid', '[Hidden]')}
• BSSID: {network.get('bssid', 'Unknown')}
• Channel: {network.get('channel', 'Unknown')}
• Signal Strength: {network.get('signal_strength', 'Unknown')} dBm
• Encryption: {network.get('encryption', 'Unknown')}
• Vendor: {network.get('vendor', 'Unknown')}

Threat Analysis:
• Threat Score: {analysis.get('overall_score', 0):.1f}%
• Confidence: {analysis.get('confidence', 0)*100:.1f}%

Threat Indicators:
{chr(10).join(f"• {reason}" for reason in analysis.get('threat_reasons', []))}

Recommendations:
{chr(10).join(f"• {rec}" for rec in analysis.get('recommendations', []))}

Time Detected: {alert['timestamp']}

This alert was generated by WiFi Security Monitor.
Do not ignore high-severity threats.
        """
        
        # Send email
        try:
            if not EMAIL_AVAILABLE:
                self.logger.warning("Email functionality not available")
                return
                
            msg = MimeMultipart()
            msg['From'] = config.EMAIL_USERNAME
            msg['Subject'] = subject
            msg.attach(MimeText(body, 'plain'))
            
            server = smtplib.SMTP(config.EMAIL_SMTP_SERVER, config.EMAIL_PORT)
            server.starttls()
            server.login(config.EMAIL_USERNAME, config.EMAIL_PASSWORD)
            
            for recipient in config.EMAIL_RECIPIENTS:
                msg['To'] = recipient
                server.send_message(msg)
                del msg['To']
            
            server.quit()
            self.logger.info(f"Email alert sent to {len(config.EMAIL_RECIPIENTS)} recipients")
            
        except Exception as e:
            self.logger.error(f"Failed to send email alert: {e}")
    
    def send_desktop_notification(self, alert: Dict):
        """Send desktop notification"""
        try:
            import gi
            gi.require_version('Notify', '0.7')
            from gi.repository import Notify
            
            network = alert['network']
            severity = alert['severity'].upper()
            
            title = f"🚨 WiFi Threat - {severity}"
            message = f"Suspicious network detected: {network.get('ssid', '[Hidden]')}\n"
            message += f"Threat Score: {alert['analysis'].get('overall_score', 0):.1f}%"
            
            # Set urgency based on severity
            urgency = {
                'low': Notify.Urgency.LOW,
                'medium': Notify.Urgency.NORMAL,
                'high': Notify.Urgency.CRITICAL,
                'critical': Notify.Urgency.CRITICAL
            }.get(alert['severity'], Notify.Urgency.NORMAL)
            
            notification = Notify.Notification.new(title, message, "security-high")
            notification.set_urgency(urgency)
            notification.set_timeout(10000)  # 10 seconds
            notification.show()
            
            self.logger.info("Desktop notification sent")
            
        except Exception as e:
            self.logger.error(f"Failed to send desktop notification: {e}")
    
    def send_log_notification(self, alert: Dict):
        """Send log-based notification"""
        network = alert['network']
        severity = alert['severity']
        score = alert['analysis'].get('overall_score', 0)
        
        log_message = f"THREAT ALERT [{severity.upper()}]: "
        log_message += f"Network '{network.get('ssid', '[Hidden]')}' "
        log_message += f"({network.get('bssid', 'Unknown')}) "
        log_message += f"- Score: {score:.1f}%"
        
        if severity in ['high', 'critical']:
            self.logger.critical(log_message)
        elif severity == 'medium':
            self.logger.warning(log_message)
        else:
            self.logger.info(log_message)
    
    def log_alert(self, alert: Dict):
        """Log alert to file for historical tracking"""
        try:
            alert_log_file = "alerts.json"
            
            # Load existing alerts
            alerts = []
            if os.path.exists(alert_log_file):
                with open(alert_log_file, 'r') as f:
                    alerts = json.load(f)
            
            # Add new alert
            alerts.append(alert)
            
            # Keep only recent alerts (last 30 days)
            cutoff_date = datetime.now() - timedelta(days=30)
            alerts = [a for a in alerts if datetime.fromisoformat(a['timestamp']) > cutoff_date]
            
            # Save alerts
            with open(alert_log_file, 'w') as f:
                json.dump(alerts, f, indent=2)
                
        except Exception as e:
            self.logger.error(f"Failed to log alert: {e}")
    
    def get_recent_alerts(self, hours: int = 24) -> List[Dict]:
        """Get alerts from the last N hours"""
        cutoff_time = datetime.now() - timedelta(hours=hours)
        return [
            alert for alert in self.alert_history
            if datetime.fromisoformat(alert['timestamp']) > cutoff_time
        ]
    
    def get_alert_statistics(self) -> Dict:
        """Get alert statistics"""
        if not self.alert_history:
            return {
                'total_alerts': 0,
                'severity_breakdown': {},
                'recent_24h': 0
            }
        
        # Count by severity
        severity_counts = {}
        recent_count = 0
        cutoff_time = datetime.now() - timedelta(hours=24)
        
        for alert in self.alert_history:
            severity = alert.get('severity', 'unknown')
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
            if datetime.fromisoformat(alert['timestamp']) > cutoff_time:
                recent_count += 1
        
        return {
            'total_alerts': len(self.alert_history),
            'severity_breakdown': severity_counts,
            'recent_24h': recent_count
        }
    
    def clear_old_alerts(self, days: int = 30):
        """Clear alerts older than specified days"""
        cutoff_date = datetime.now() - timedelta(days=days)
        self.alert_history = [
            alert for alert in self.alert_history
            if datetime.fromisoformat(alert['timestamp']) > cutoff_date
        ]
        
        self.logger.info(f"Cleared alerts older than {days} days")

# Alert message templates
ALERT_TEMPLATES = {
    'evil_twin': {
        'title': '🎭 Evil Twin Network Detected',
        'description': 'A network with a name very similar to a legitimate network has been detected',
        'urgency': 'high'
    },
    'fake_hotspot': {
        'title': '🕳️ Fake Hotspot Detected',
        'description': 'A network with characteristics of a fake public hotspot has been found',
        'urgency': 'medium'
    },
    'open_network': {
        'title': '🔓 Unencrypted Network',
        'description': 'An open network with suspicious characteristics detected',
        'urgency': 'medium'
    },
    'signal_anomaly': {
        'title': '📡 Signal Anomaly',
        'description': 'Unusual signal strength patterns detected',
        'urgency': 'low'
    },
    'multiple_threats': {
        'title': '⚠️ Multiple Threats',
        'description': 'Network matches multiple threat patterns',
        'urgency': 'critical'
    }
}

def create_alert_system() -> AlertSystem:
    """Factory function to create alert system"""
    return AlertSystem()

# Example usage
if __name__ == "__main__":
    # Test alert system
    alert_system = AlertSystem()
    
    # Sample threat data
    sample_network = {
        'ssid': 'Free WiFi',
        'bssid': '00:11:22:33:44:55',
        'channel': 6,
        'signal_strength': -20,
        'encryption': 'Open'
    }
    
    sample_analysis = {
        'overall_score': 85.0,
        'severity_level': 'high',
        'threat_reasons': [
            'Suspicious SSID pattern',
            'No encryption',
            'Very strong signal'
        ],
        'recommendations': [
            '🚨 Do not connect to this network',
            '🚨 Report to local authorities'
        ]
    }
    
    # Send test alert
    alert_system.send_threat_alert(sample_network, sample_analysis)
    
    # Get statistics
    stats = alert_system.get_alert_statistics()
    print(f"Alert statistics: {json.dumps(stats, indent=2)}")